//! rvmfg is the VM for the
//! [sfg programming language](https://github.com/CosineGaming/sfg).
//! It will run the bcfg bytecode generated by rsfg. If you're
//! just trying to run an sfg program in the terminal, you want an
//! [rsfg](https://github.com/CosineGaming/sfg/tree/master/rsfg) binary. If
//! you just want to run a `bcfg` file in the terminal, you want to use this as
//! a binary\*
//!
//! If you're still with us, hopefully you have
//! either a `bcfg` file
//! or some freshly compiled bcfg bytecode from the rsfg compiler. Next
//! you're gonna want to check out [Thread], probably calling [Thread::new]
//! with your code. Then you'll want to call it, either with [call] or some
//! combo of [Thread::arg] and [Thread::call_name]. To decide which, read the
//! [Thread] documentation.
//!
//! \* To run as a binary, run `cargo run <path_to_bcfg_file>`, (or use
//! `rvmfg` if you have a rvmfg binary) simple as that!

#[macro_use]
extern crate log;

mod read;
mod sfg_std;
mod thread;

pub use thread::Thread;
pub use thread::StateError;

/// Convenience macro for dealing with function calls with arguments. Note
/// you have to have [Argable] in scope and macro_use for the crate.
/// ```
/// #[macro_use] extern crate rvmfg;
/// use rvmfg::Argable;
/// # let program = include_bytes!("../tests/rvmfg-call-doc.bcfg").to_vec();
/// # let mut thread = rvmfg::Thread::new(program);
/// call![thread.fn_to_call(5, "hello")];
/// ```
#[macro_export]
macro_rules! call {
    ( $thread:ident.$function:ident($( $push:expr ),*) ) => {
        {
            $(
                $push.push_arg(&mut $thread);
            )*
            $thread.call_name(stringify!($function));
            if $thread.get_return_type(stringify!($function)).is_some() {
                Some($thread.pop_return())
            } else { None }
        }
    };
}

/// If a type implements Argable, it can be pushed onto a thread's argument
/// list with `argable.push_arg`. This is used behind the scenes for [call]
/// so be sure to have Argable in scope when using that macro.
///
/// All VM types implement Argable. They're
/// all just basic reinterpret casts. The point of this is so that you as
/// a rust\* user don't have to mess around with internal type casts and
/// can focus on the pushing.
///
/// There are a few good reasons to use a trait for this. One is that we
/// can add types without messing with Thread code at all, because it's really
/// of no concern to the VM. This also allows you as a user to impl it, eg
/// if you have a UserID that you want to be able to push to rvmfg as an i32.
/// The other advantage of method-syntax is it makes it dead easy to implement
/// the call macro (essentially becoming the visitor pattern)
///
/// \* i say a rust user because a C user does not have a trait system like
/// rust does, hence these are not exported. However you can still use
/// [Thread::arg] to create an equally powerful C-idiomatic API, and i plan
/// to do so.
pub trait Argable {
    /// Consume self and push onto the given thread using [Thread::arg] or
    /// [Thread::arg_str_lit]
    fn push_arg(self, thread: &mut Thread);
}
impl Argable for i32 {
    fn push_arg(self, thread: &mut Thread) {
        thread.arg(self);
    }
}
impl Argable for String {
    fn push_arg(self, thread: &mut Thread) {
        thread.arg_str_lit(self);
    }
}
impl Argable for &str {
    fn push_arg(self, thread: &mut Thread) {
        self.to_string().push_arg(thread);
    }
}
impl Argable for f32 {
    fn push_arg(self, thread: &mut Thread) {
        thread.arg(f_as_i(self));
    }
}
impl Argable for bool {
    fn push_arg(self, thread: &mut Thread) {
        thread.arg(self as i32);
    }
}
fn f_as_i(what: f32) -> i32 {
    f32::to_bits(what) as i32
}
